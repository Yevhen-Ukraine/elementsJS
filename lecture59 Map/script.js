'use strict';

// const user = {
//     name: 'Alex',
//     surname: 'Smith',
//     birthdey: '20/04/1993',
//     swowMyPablicData: function () {
//         console.log(`${this.name} ${this.surname}`);
//     }
// }
//console.log(user);

/* console.log(typeof(Object.keys(user)[0])); */ // Проверяем что ключи у нас записываються в формате string. Поместить обьект в качестве ключа не получиться, будет ошибка

/* Map называються спецефические структуры данных которрые очень похожи на обьект но у них есть свои методы, т.е. может использоваться и обьект и массив и все что угодно*/

/* const shops = [
    {rise: 500},
    {oil: 200},
    {bread: 50}    
];

const map = new Map();

map.set(shops[0], 5000);
// чтобы заполнить карту можно воспользоваться несколькими способами например псстрочно
map.set(shops[1], 6000);
map.set(shops[2], 8000);


console.log(map); */

// Более рациональный вариант того же

const shops = [
    {rise: 500},
    {oil: 200},
    {bread: 50}    
];

const budget = [5000, 15000, 25000];

/* Так карта выглядит изнутри, массив массивов */
const map = new Map([
    [{paper: 400}, 8000]
]);

shops.forEach((shop, i) => {
    map.set(shop, budget[i]);
})

console.log(map);
// console.log(map.get(shops[0])); //получение значений (получим первый элемент)
// console.log(map.hes(shops[0])); // Проверка обьекта на существование
// map.delete(key); // удаляет что-то из карты 
// map.clear(); // Очистка карты
// map.size; // Колличество элементов на данный момент внутри карты 
// map.keys() // 

/* 4 СПОСОБА ПЕРЕБРАТЬ КАРТЫ */
/* 1. */
// map.keys() // Возвращает итерируемый (перебираемый) обьект по ключам
// Пример:
// Необходимо получить список всех товаров во всех магазинах

// const goods = [];
// for (let shop of map.keys()) {
//     goods.push(Object.keys(shop)[0])
// }
// console.log(goods);
// Получаем массив с наименованием всех товаров во всех магазинах

/* 2. Этот метод позволяет получить вместо ключей значения (итерируемый обьект по значениям) */
// for (let price of map.values()) {
//     console.log(price);
// }

/* 3. Метод entries позволяет получить массив с массивами которые имеют два элемента: свойство и значение*/
// for (let price of map.entries()) {
//     console.log(price);
// } 
// С помощью этого метода можно выполнить два предидущих

/* Можно сразу для удобства деструктуризировать  */
// for (let [shop, price] of map.entries()) {
//     console.log(shop, price);
// }
// Получаем разделенную структуру

/* 4. Использование метода forEach */

// map.forEach((value, key, map) => { /*Аргументы: Значение, ключ, карта на которую можно ссылаться внутри колбек функции */
//     console.log(key, value);
// });

/* Небольшая полезность */
// Карты очень похожи на обьекты, данные могут храниться и там и там. Для того чтобы не терять гибкость эти сруктуры мы можем преобразовывать одна в другую

const user = {
    name: 'Alex',
    surname: 'Smith',
    birthdey: '20/04/1993',
    swowMyPablicData: function () {
        console.log(`${this.name} ${this.surname}`);
    }
}

// Допустим я хочу перевести этот обьект в формат карты

const userMap = new Map(Object.entries(user));
//console.log(userMap);


// Допустим какая либо функция принимает в себя только обьект и не умеет работать с картами

const newUserObj = Object.fromEntries(userMap);
console.log(newUserObj);

/* Главные отличия */
/* У Map ключи могут быть чем угодно (массивы, обьекты, функции, цифры) у обьектов ключами могут быть только строки*/
// В картах порядок свойств такой как мы их добовляи, это полезно при различных переборах. У обьектов нет четкого порядка в зависимости от того когда это свойство было добавлено. Если мы динамически добавляем свойство, то оно может быть добавлено в любое место.
// При создании пустой карты в ней ничего не будет содержаться, в том числе наследуемых свойств через прототип
// Карты легко перебирать, с обьектами не все так просто
// Размеры карты легко получить через свойство size, в случае обьекта нам его сначало необходимо трансформировать в массиви потом получить его длинну, для этого используеться команда Object.keys, получаем массив свойств и затем уже узнаем длинну этого массива