'use strict';

console.log('Запрос даних...');

const req = new Promise((resolve, reject) => { //Аргументы вместо которых будут подставляться функции. Первый аргумент resolve означает что обещание выполнилось правильно, так как ожидали. Второй аргумент означает что обещание не выполнилось
    setTimeout(() => {
        console.log('Підготовка даних...');
    
        const product = {
            name: 'TV',
            price: 1000
        };
    
        resolve(product); // Передаем сюда данные которые будут идти дальше (то что получим от условного сервера)

        // Внутри setTimeout имитация асинхронного кода
    
    }, 1000);    
});

// Этот метод функции resolve предназначен для обработки положительногорезультата. Он принимает в себя аргумент resolve с функцией. По сути функция resolve описана в колбэк функции метода then
// req.then((product) => { 
//     setTimeout(() => {
//         product.status = 'order';
//         console.log(product);
//     }, 2000);
// });

req.then((product) => { 
    /* const req2 = */return new Promise((resolve, reject) => {
        setTimeout(() => {
            product.status = 'order';
            resolve(product);
        }, 2000);
    });

}).then(data => { // Данные data придут из предидущей функции resolve
    data.modify = true; // Замодифицируем данные
    return data;
    
}).then(data => {
    console.log(data);
}).catch(() => { // Этот блок кода срабатывает если что-то пошло не так
    console.error('Произошла ошибка');
}).finally(() => { // В этот участок кода мы можем поместить участок структуры которая очищает форму от старых данных
    console.log('Finally');
});
// Т.о операции выполняются по цепочке независимо от того синхронный код или асинхронный

/* Методы  */

const test = time => {
    return new Promise(resolve => {
        setTimeout(() => resolve(), time);
    });
};

// test(1000).then(() => console.log('1000 ms'));

// test(2000).then(() => console.log('2000 ms')); 

Promise.all([test(1000), test(2000)]).then(() => {
    console.log('ALL'); // Эта команда служит для того чтобы мы точно убедились в выполнении всех промисов. Например мы можем делать несколько запросов на разные сервера, они в свою очередь могут с разной скоростью отвечать, но при этом мы хотим чтобы наши изображения появлялись одновременно на сайте. Promise.all ждет окончания всех промисов и только поточ что-то делает используя then, если все хорошо, либо catch, если какойто промис не выполнился
});

Promise.race([test(1000), test(2000)]).then(() => {
    console.log('ALL');
    // Эта команда ждет выполнения первого промиса и затем выполняет необходимую последовательность действий.
}); 